{
  "version": 3,
  "sources": ["../../../node_modules/vue-wrap-balancer/node_modules/nanoid/index.browser.js", "../../../node_modules/vue-wrap-balancer/src/index.ts", "../../../node_modules/vue-wrap-balancer/src/utils.ts"],
  "sourcesContent": ["import { urlAlphabet } from './url-alphabet/index.js'\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nlet nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n", "/*!\n * Original code by Shu Ding\n * MIT Licensed, Copyright 2022 Shu Ding, see https://github.com/shuding/react-wrap-balancer/blob/main/LICENSE.md for details\n *\n * Credits to the team:\n * https://github.com/shuding/react-wrap-balancer/blob/main/src/index.tsx\n */\nimport { computed, defineComponent, h, inject, onUnmounted, provide, ref, unref, watchPostEffect, withDirectives } from 'vue'\nimport { nanoid } from 'nanoid'\nimport { vBindOnce } from './utils'\n\nconst SYMBOL_KEY = '__wrap_b'\nconst SYMBOL_NATIVE_KEY = '__wrap_n'\nconst SYMBOL_OBSERVER_KEY = '__wrap_o'\n\ntype RelayoutFn = (\n  id: string | number,\n  ratio: number,\n  wrapper?: HTMLElement\n) => void\n\ndeclare global {\n  interface Window {\n    [SYMBOL_KEY]: RelayoutFn\n    // A flag to indicate whether the browser supports text-balancing natively.\n    // undefined: not injected\n    // 1: injected and supported\n    // 2: injected but not supported\n    [SYMBOL_NATIVE_KEY]?: number\n  }\n\n  interface HTMLElement {\n    [SYMBOL_OBSERVER_KEY]: ResizeObserver | undefined\n  }\n}\n\nconst relayout: RelayoutFn = (id, ratio, wrapper) => {\n  wrapper = wrapper || (document.querySelector(`[data-br=\"${id}\"]`) as HTMLElement)\n  const container = wrapper.parentElement as HTMLElement\n\n  const update = (width: number) => (wrapper!.style.maxWidth = `${width}px`)\n\n  // Reset wrapper width\n  wrapper.style.maxWidth = ''\n\n  // Get the intial container size\n  const width = container.clientWidth\n  const height = container.clientHeight\n\n  // Synchronously do binary search and calculate the layout\n  let lower: number = width / 2 - 0.25\n  let upper: number = width + 0.5\n  let middle: number\n\n  if (width) {\n    // Ensure we don't search widths lower than when the text overflows\n    update(lower)\n    lower = Math.max(wrapper.scrollWidth, lower)\n\n    while (lower + 1 < upper) {\n      middle = Math.round((lower + upper) / 2)\n      update(middle)\n      if (container.clientHeight === height)\n        upper = middle\n\n      else\n        lower = middle\n    }\n\n    // Update the wrapper width\n    update(upper * ratio + width * (1 - ratio))\n  }\n\n  // Create a new observer if we don't have one.\n  // Note that we must inline the key here as we use `toString()` to serialize\n  // the function.\n  if (!wrapper.__wrap_o) {\n    (wrapper.__wrap_o = new ResizeObserver(() => {\n      self.__wrap_b(0, +wrapper!.dataset.brr!, wrapper)\n    })).observe(container)\n  }\n}\n\nconst RELAYOUT_STR = relayout.toString()\n\nconst isTextWrapBalanceSupported = '(self.CSS&&CSS.supports(\"text-wrap\",\"balance\")?1:2)'\n\nfunction createScriptElement(injected: boolean, nonce?: string, suffix?: string) {\n  if (suffix)\n    suffix = `self.${SYMBOL_NATIVE_KEY}!=1&&${suffix}`\n\n  return h('script', {\n    innerHTML: (injected ? '' : `self.${SYMBOL_NATIVE_KEY}=self.${SYMBOL_NATIVE_KEY}||${isTextWrapBalanceSupported};self.${SYMBOL_KEY}=${RELAYOUT_STR};`) + suffix,\n    nonce,\n  })\n}\n\nexport const BalancerProvider = defineComponent({\n  name: 'BalancerProvider',\n  props: {\n    /**\n     * An option to skip the re-balance logic\n     * and use the native CSS text-balancing if supported.\n     * @default true\n     */\n    preferNative: {\n      type: Boolean,\n      required: false,\n      default: true,\n    },\n    /**\n     * The nonce attribute to allowlist inline script injection by the component\n     */\n    nonce: {\n      type: String,\n      required: false,\n    },\n  },\n  setup(props, { slots }) {\n    const preferNative = computed(() => props.preferNative)\n    provide('BALANCER_PROVIDER', {\n      preferNative,\n      hasProvider: true,\n    })\n\n    return () => [\n      createScriptElement(false, props.nonce),\n      slots.default?.(),\n    ]\n  },\n})\n\nexport default defineComponent({\n  name: 'WrapBalancer',\n  props: {\n    /**\n     * The HTML tag to use for the wrapper element.\n     * @default 'span'\n     */\n    as: {\n      type: String,\n      required: false,\n      default: 'span',\n    },\n    /**\n     * The balance ratio of the wrapper width (0 <= ratio <= 1).\n     * 0 means the wrapper width is the same as the container width (no balance, browser default).\n     * 1 means the wrapper width is the minimum (full balance, most compact).\n     * @default 1\n     */\n    ratio: {\n      type: Number,\n      required: false,\n      default: 1,\n    },\n    /**\n     * An option to skip the re-balance logic\n     * and use the native CSS text-balancing if supported.\n     * @default true\n     */\n    preferNative: {\n      type: Boolean,\n      required: false,\n      default: true,\n    },\n    /**\n     * The nonce attribute to allowlist inline script injection by the component.\n     */\n    nonce: {\n      type: String,\n      required: false,\n    },\n  },\n  setup(props, { slots, attrs }) {\n    const As = props.as\n    const id = attrs.id || nanoid(5)\n    const wrapperRef = ref<HTMLElement | null>(null)\n    const contextValue = inject('BALANCER_PROVIDER', {\n      preferNative: true,\n      hasProvider: false,\n    })\n\n    const preferNativeBalancing = computed(() => props.preferNative ?? unref(contextValue.preferNative))\n\n    // Re-balance on content change and on mount/hydration\n    watchPostEffect(() => {\n      // Skip if the browser supports text-balancing natively.\n      if (preferNativeBalancing.value && typeof self !== 'undefined' && self[SYMBOL_NATIVE_KEY] === 1)\n        return\n\n      if (wrapperRef.value)\n        (self[SYMBOL_KEY] = relayout)(0, props.ratio, wrapperRef.value)\n    })\n\n    // Remove the observer when unmounting.\n    onUnmounted(() => {\n      // Skip if the browser supports text-balancing natively.\n      if (preferNativeBalancing.value && typeof self !== 'undefined' && self[SYMBOL_NATIVE_KEY] === 1)\n        return\n\n      if (!wrapperRef.value)\n        return\n\n      const resizeObserver = wrapperRef.value[SYMBOL_OBSERVER_KEY]\n      if (resizeObserver) {\n        resizeObserver.disconnect()\n        delete wrapperRef.value[SYMBOL_OBSERVER_KEY]\n      }\n    })\n\n    return () => withDirectives(h(As, {\n      ...attrs,\n      'data-brr': props.ratio,\n      'ref': wrapperRef,\n      'style': {\n        ...attrs.style as Record<string, string>,\n        display: 'inline-block',\n        verticalAlign: 'top',\n        textDecoration: 'inherit',\n        textWrap: preferNativeBalancing.value ? 'balance' : 'initial',\n      },\n    }, [\n      slots.default?.(),\n      withDirectives(createScriptElement(contextValue.hasProvider, props.nonce, `self.${SYMBOL_KEY}(document.currentScript.dataset.ssrId,${props.ratio})`), [\n        [vBindOnce, ['data-ssr-id', id]]],\n      ),\n    ]), [\n      [vBindOnce, ['data-br', id]],\n    ])\n  },\n})\n", "import type { Directive, DirectiveBinding } from 'vue'\nimport { nanoid } from 'nanoid'\n\nexport const vBindOnce: Directive<HTMLElement> = {\n  created(el, binding: DirectiveBinding<[string, string]>) {\n    const [key, value] = binding.value\n    el.setAttribute(key, value || nanoid(5))\n  },\n  getSSRProps(binding: DirectiveBinding<[string, string]>) {\n    const [key, value] = binding.value\n    return {\n      [key]: value,\n    }\n  },\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;AAmBA,IAAI,SAAS,CAAC,OAAO,OACnB,OAAO,gBAAgB,IAAI,WAAW,IAAI,CAAC,EAAE,OAAO,CAAC,IAAI,SAAS;AAChE,UAAQ;AACR,MAAI,OAAO,IAAI;AACb,UAAM,KAAK,SAAS,EAAE;AAAA,EACxB,WAAW,OAAO,IAAI;AACpB,WAAO,OAAO,IAAI,SAAS,EAAE,EAAE,YAAY;AAAA,EAC7C,WAAW,OAAO,IAAI;AACpB,UAAM;AAAA,EACR,OAAO;AACL,UAAM;AAAA,EACR;AACA,SAAO;AACT,GAAG,EAAE;;;AE7BA,IAAM,YAAoC;EAC/C,QAAQ,IAAI,SAA6C;AACvD,UAAM,CAAC,KAAK,KAAK,IAAI,QAAQ;AAC7B,OAAG,aAAa,KAAK,SAAS,OAAO,CAAC,CAAC;EACzC;EACA,YAAY,SAA6C;AACvD,UAAM,CAAC,KAAK,KAAK,IAAI,QAAQ;AAC7B,WAAO;MACL,CAAC,GAAA,GAAM;IACT;EACF;AACF;ADHA,IAAM,aAAa;AACnB,IAAM,oBAAoB;AAC1B,IAAM,sBAAsB;AAuB5B,IAAM,WAAuB,CAAC,IAAI,OAAO,YAAY;AACnD,YAAU,WAAY,SAAS,cAAc,aAAa,EAAA,IAAM;AAChE,QAAM,YAAY,QAAQ;AAE1B,QAAM,SAAS,CAACA,WAAmB,QAAS,MAAM,WAAW,GAAGA,MAAAA;AAGhE,UAAQ,MAAM,WAAW;AAGzB,QAAM,QAAQ,UAAU;AACxB,QAAM,SAAS,UAAU;AAGzB,MAAI,QAAgB,QAAQ,IAAI;AAChC,MAAI,QAAgB,QAAQ;AAC5B,MAAI;AAEJ,MAAI,OAAO;AAET,WAAO,KAAK;AACZ,YAAQ,KAAK,IAAI,QAAQ,aAAa,KAAK;AAE3C,WAAO,QAAQ,IAAI,OAAO;AACxB,eAAS,KAAK,OAAO,QAAQ,SAAS,CAAC;AACvC,aAAO,MAAM;AACb,UAAI,UAAU,iBAAiB;AAC7B,gBAAQ;;AAGR,gBAAQ;IACZ;AAGA,WAAO,QAAQ,QAAQ,SAAS,IAAI,MAAM;EAC5C;AAKA,MAAI,CAAC,QAAQ,UAAU;AACrB,KAAC,QAAQ,WAAW,IAAI,eAAe,MAAM;AAC3C,WAAK,SAAS,GAAG,CAAC,QAAS,QAAQ,KAAM,OAAO;IAClD,CAAC,GAAG,QAAQ,SAAS;EACvB;AACF;AAEA,IAAM,eAAe,SAAS,SAAS;AAEvC,IAAM,6BAA6B;AAEnC,SAAS,oBAAoB,UAAmB,OAAgB,QAAiB;AAC/E,MAAI;AACF,aAAS,QAAQ,iBAAA,QAAyB,MAAA;AAE5C,SAAO,EAAE,UAAU;IACjB,YAAY,WAAW,KAAK,QAAQ,iBAAA,SAA0B,iBAAA,KAAsB,0BAAA,SAAmC,UAAA,IAAc,YAAA,OAAmB;IACxJ;EACF,CAAC;AACH;AAEO,IAAM,mBAAmB,gBAAgB;EAC9C,MAAM;EACN,OAAO;IAML,cAAc;MACZ,MAAM;MACN,UAAU;MACV,SAAS;IACX;IAIA,OAAO;MACL,MAAM;MACN,UAAU;IACZ;EACF;EACA,MAAM,OAAO,EAAE,MAAM,GAAG;AACtB,UAAM,eAAe,SAAS,MAAM,MAAM,YAAY;AACtD,YAAQ,qBAAqB;MAC3B;MACA,aAAa;IACf,CAAC;AAED,WAAO,MAAG;AA7Hd,UAAA;AA6HiB,aAAA;QACX,oBAAoB,OAAO,MAAM,KAAK;SACtC,KAAA,MAAM,YAAN,OAAA,SAAA,GAAA,KAAA,KAAA;MACF;IAAA;EACF;AACF,CAAC;AAED,IAAO,cAAQ,gBAAgB;EAC7B,MAAM;EACN,OAAO;IAKL,IAAI;MACF,MAAM;MACN,UAAU;MACV,SAAS;IACX;IAOA,OAAO;MACL,MAAM;MACN,UAAU;MACV,SAAS;IACX;IAMA,cAAc;MACZ,MAAM;MACN,UAAU;MACV,SAAS;IACX;IAIA,OAAO;MACL,MAAM;MACN,UAAU;IACZ;EACF;EACA,MAAM,OAAO,EAAE,OAAO,MAAM,GAAG;AAC7B,UAAM,KAAK,MAAM;AACjB,UAAM,KAAK,MAAM,MAAMC,OAAO,CAAC;AAC/B,UAAM,aAAa,IAAwB,IAAI;AAC/C,UAAM,eAAe,OAAO,qBAAqB;MAC/C,cAAc;MACd,aAAa;IACf,CAAC;AAED,UAAM,wBAAwB,SAAS,MAAG;AAtL9C,UAAA;AAsLiD,cAAA,KAAA,MAAM,iBAAN,OAAA,KAAsB,MAAM,aAAa,YAAY;IAAA,CAAC;AAGnG,oBAAgB,MAAM;AAEpB,UAAI,sBAAsB,SAAS,OAAO,SAAS,eAAe,KAAK,iBAAA,MAAuB;AAC5F;AAEF,UAAI,WAAW;AACb,SAAC,KAAK,UAAA,IAAc,UAAU,GAAG,MAAM,OAAO,WAAW,KAAK;IAClE,CAAC;AAGD,gBAAY,MAAM;AAEhB,UAAI,sBAAsB,SAAS,OAAO,SAAS,eAAe,KAAK,iBAAA,MAAuB;AAC5F;AAEF,UAAI,CAAC,WAAW;AACd;AAEF,YAAM,iBAAiB,WAAW,MAAM,mBAAA;AACxC,UAAI,gBAAgB;AAClB,uBAAe,WAAW;AAC1B,eAAO,WAAW,MAAM,mBAAA;MAC1B;IACF,CAAC;AAED,WAAO,MAAG;AAlNd,UAAA;AAkNiB,aAAA,eAAe,EAAE,IAAI;QAChC,GAAG;QACH,YAAY,MAAM;QAClB,OAAO;QACP,SAAS;UACP,GAAG,MAAM;UACT,SAAS;UACT,eAAe;UACf,gBAAgB;UAChB,UAAU,sBAAsB,QAAQ,YAAY;QACtD;MACF,GAAG;SACD,KAAA,MAAM,YAAN,OAAA,SAAA,GAAA,KAAA,KAAA;QACA;UAAe,oBAAoB,aAAa,aAAa,MAAM,OAAO,QAAQ,UAAA,yCAAmD,MAAM,KAAA,GAAQ;UAAG;YACpJ,CAAC,WAAW,CAAC,eAAe,EAAE,CAAC;UAAC;QAClC;MACF,CAAC,GAAG;QACF,CAAC,WAAW,CAAC,WAAW,EAAE,CAAC;MAC7B,CAAC;IAAA;EACH;AACF,CAAC;",
  "names": ["width", "nanoid"]
}
